package main

import (
	"fmt"
	"os"
	"text/tabwriter"
	"time"

	"apiclient"
	"cli/pkg/client"

	"github.com/spf13/cobra"
)

var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all sandboxes",
	Long:  `List all sandboxes in your Daytona organization.`,
	Run: func(cmd *cobra.Command, args []string) {
		// Get command flags
		verbose, _ := cmd.Flags().GetBool("verbose")
		labels, _ := cmd.Flags().GetString("labels")
		includeErrored, _ := cmd.Flags().GetBool("include-errored")

		// Create API client
		apiClient, err := client.NewClient()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error creating API client: %s\n", err)
			os.Exit(1)
		}

		// List sandboxes
		var allSandboxes []apiclient.Sandbox
		if verbose || labels != "" || includeErrored {
			// Use advanced options
			allSandboxes, err = apiClient.ListSandboxesWithOptions(verbose, labels, includeErrored)
		} else {
			// Use simple list
			allSandboxes, err = apiClient.ListSandboxes()
		}

		if err != nil {
			fmt.Fprintf(os.Stderr, "Error listing sandboxes: %s\n", err)
			os.Exit(1)
		}

		// Filter sandboxes that have dispense-name label
		var sandboxes []apiclient.Sandbox
		for _, sb := range allSandboxes {
			if dispenseName, hasDispenseName := sb.Labels["dispense-name"]; hasDispenseName && dispenseName != "" {
				sandboxes = append(sandboxes, sb)
			}
		}

		// Display results
		if len(sandboxes) == 0 {
			fmt.Println("No sandboxes with dispense-name label found.")
			fmt.Println("Only sandboxes created with the 'default' command are shown.")
			return
		}

		// Create tab writer for formatted output
		w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
		defer w.Flush()

		// Print header
		if verbose {
			fmt.Fprintln(w, "ID\tDispense Name\tOrganization\tUser\tTarget\tState\tCPU\tMemory\tCreated\tUpdated")
		} else {
			fmt.Fprintln(w, "ID\tDispense Name\tTarget\tState\tCPU\tMemory\tCreated")
		}

		// Print sandboxes
		for _, sb := range sandboxes {
			// Get dispense-name from labels
			dispenseName := "N/A"
			if name, exists := sb.Labels["dispense-name"]; exists {
				dispenseName = name
			}
			
			createdAt := "N/A"
			if sb.CreatedAt != nil {
				if t, err := time.Parse(time.RFC3339, *sb.CreatedAt); err == nil {
					createdAt = t.Format("2006-01-02 15:04")
				}
			}

			updatedAt := "N/A"
			if sb.UpdatedAt != nil {
				if t, err := time.Parse(time.RFC3339, *sb.UpdatedAt); err == nil {
					updatedAt = t.Format("2006-01-02 15:04")
				}
			}

			state := "Unknown"
			if sb.State != nil {
				state = string(*sb.State)
			}

			if verbose {
				fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\t%.1f\t%.1f\t%s\t%s\n",
					sb.Id,
					dispenseName,
					sb.OrganizationId,
					sb.User,
					sb.Target,
					state,
					sb.Cpu,
					sb.Memory,
					createdAt,
					updatedAt,
				)
			} else {
				fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%.1f\t%.1f\t%s\n",
					sb.Id,
					dispenseName,
					sb.Target,
					state,
					sb.Cpu,
					sb.Memory,
					createdAt,
				)
			}
		}
	},
}

func init() {
	// Add flags
	listCmd.Flags().BoolP("verbose", "v", false, "Show detailed information")
	listCmd.Flags().StringP("labels", "l", "", "Filter by labels (comma-separated key=value pairs)")
	listCmd.Flags().Bool("include-errored", false, "Include errored and deleted sandboxes")
}
