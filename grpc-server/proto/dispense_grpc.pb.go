// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.12.4
// source: proto/dispense.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	DispenseService_CreateSandbox_FullMethodName   = "/dispense.DispenseService/CreateSandbox"
	DispenseService_ListSandboxes_FullMethodName   = "/dispense.DispenseService/ListSandboxes"
	DispenseService_DeleteSandbox_FullMethodName   = "/dispense.DispenseService/DeleteSandbox"
	DispenseService_GetSandbox_FullMethodName      = "/dispense.DispenseService/GetSandbox"
	DispenseService_WaitForSandbox_FullMethodName  = "/dispense.DispenseService/WaitForSandbox"
	DispenseService_RunClaudeTask_FullMethodName   = "/dispense.DispenseService/RunClaudeTask"
	DispenseService_GetClaudeStatus_FullMethodName = "/dispense.DispenseService/GetClaudeStatus"
	DispenseService_GetClaudeLogs_FullMethodName   = "/dispense.DispenseService/GetClaudeLogs"
	DispenseService_GetAPIKey_FullMethodName       = "/dispense.DispenseService/GetAPIKey"
	DispenseService_SetAPIKey_FullMethodName       = "/dispense.DispenseService/SetAPIKey"
	DispenseService_ValidateAPIKey_FullMethodName  = "/dispense.DispenseService/ValidateAPIKey"
)

// DispenseServiceClient is the client API for DispenseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Main Dispense service that aggregates all functionality
type DispenseServiceClient interface {
	// Sandbox management
	CreateSandbox(ctx context.Context, in *CreateSandboxRequest, opts ...grpc.CallOption) (*CreateSandboxResponse, error)
	ListSandboxes(ctx context.Context, in *ListSandboxesRequest, opts ...grpc.CallOption) (*ListSandboxesResponse, error)
	DeleteSandbox(ctx context.Context, in *DeleteSandboxRequest, opts ...grpc.CallOption) (*DeleteSandboxResponse, error)
	GetSandbox(ctx context.Context, in *GetSandboxRequest, opts ...grpc.CallOption) (*GetSandboxResponse, error)
	WaitForSandbox(ctx context.Context, in *WaitForSandboxRequest, opts ...grpc.CallOption) (*WaitForSandboxResponse, error)
	// Claude operations
	RunClaudeTask(ctx context.Context, in *RunClaudeTaskRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RunClaudeTaskResponse], error)
	GetClaudeStatus(ctx context.Context, in *GetClaudeStatusRequest, opts ...grpc.CallOption) (*GetClaudeStatusResponse, error)
	GetClaudeLogs(ctx context.Context, in *GetClaudeLogsRequest, opts ...grpc.CallOption) (*GetClaudeLogsResponse, error)
	// Configuration management
	GetAPIKey(ctx context.Context, in *GetAPIKeyRequest, opts ...grpc.CallOption) (*GetAPIKeyResponse, error)
	SetAPIKey(ctx context.Context, in *SetAPIKeyRequest, opts ...grpc.CallOption) (*SetAPIKeyResponse, error)
	ValidateAPIKey(ctx context.Context, in *ValidateAPIKeyRequest, opts ...grpc.CallOption) (*ValidateAPIKeyResponse, error)
}

type dispenseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDispenseServiceClient(cc grpc.ClientConnInterface) DispenseServiceClient {
	return &dispenseServiceClient{cc}
}

func (c *dispenseServiceClient) CreateSandbox(ctx context.Context, in *CreateSandboxRequest, opts ...grpc.CallOption) (*CreateSandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSandboxResponse)
	err := c.cc.Invoke(ctx, DispenseService_CreateSandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) ListSandboxes(ctx context.Context, in *ListSandboxesRequest, opts ...grpc.CallOption) (*ListSandboxesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSandboxesResponse)
	err := c.cc.Invoke(ctx, DispenseService_ListSandboxes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) DeleteSandbox(ctx context.Context, in *DeleteSandboxRequest, opts ...grpc.CallOption) (*DeleteSandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSandboxResponse)
	err := c.cc.Invoke(ctx, DispenseService_DeleteSandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) GetSandbox(ctx context.Context, in *GetSandboxRequest, opts ...grpc.CallOption) (*GetSandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSandboxResponse)
	err := c.cc.Invoke(ctx, DispenseService_GetSandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) WaitForSandbox(ctx context.Context, in *WaitForSandboxRequest, opts ...grpc.CallOption) (*WaitForSandboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WaitForSandboxResponse)
	err := c.cc.Invoke(ctx, DispenseService_WaitForSandbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) RunClaudeTask(ctx context.Context, in *RunClaudeTaskRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[RunClaudeTaskResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DispenseService_ServiceDesc.Streams[0], DispenseService_RunClaudeTask_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RunClaudeTaskRequest, RunClaudeTaskResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DispenseService_RunClaudeTaskClient = grpc.ServerStreamingClient[RunClaudeTaskResponse]

func (c *dispenseServiceClient) GetClaudeStatus(ctx context.Context, in *GetClaudeStatusRequest, opts ...grpc.CallOption) (*GetClaudeStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClaudeStatusResponse)
	err := c.cc.Invoke(ctx, DispenseService_GetClaudeStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) GetClaudeLogs(ctx context.Context, in *GetClaudeLogsRequest, opts ...grpc.CallOption) (*GetClaudeLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetClaudeLogsResponse)
	err := c.cc.Invoke(ctx, DispenseService_GetClaudeLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) GetAPIKey(ctx context.Context, in *GetAPIKeyRequest, opts ...grpc.CallOption) (*GetAPIKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAPIKeyResponse)
	err := c.cc.Invoke(ctx, DispenseService_GetAPIKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) SetAPIKey(ctx context.Context, in *SetAPIKeyRequest, opts ...grpc.CallOption) (*SetAPIKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetAPIKeyResponse)
	err := c.cc.Invoke(ctx, DispenseService_SetAPIKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dispenseServiceClient) ValidateAPIKey(ctx context.Context, in *ValidateAPIKeyRequest, opts ...grpc.CallOption) (*ValidateAPIKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateAPIKeyResponse)
	err := c.cc.Invoke(ctx, DispenseService_ValidateAPIKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DispenseServiceServer is the server API for DispenseService service.
// All implementations must embed UnimplementedDispenseServiceServer
// for forward compatibility.
//
// Main Dispense service that aggregates all functionality
type DispenseServiceServer interface {
	// Sandbox management
	CreateSandbox(context.Context, *CreateSandboxRequest) (*CreateSandboxResponse, error)
	ListSandboxes(context.Context, *ListSandboxesRequest) (*ListSandboxesResponse, error)
	DeleteSandbox(context.Context, *DeleteSandboxRequest) (*DeleteSandboxResponse, error)
	GetSandbox(context.Context, *GetSandboxRequest) (*GetSandboxResponse, error)
	WaitForSandbox(context.Context, *WaitForSandboxRequest) (*WaitForSandboxResponse, error)
	// Claude operations
	RunClaudeTask(*RunClaudeTaskRequest, grpc.ServerStreamingServer[RunClaudeTaskResponse]) error
	GetClaudeStatus(context.Context, *GetClaudeStatusRequest) (*GetClaudeStatusResponse, error)
	GetClaudeLogs(context.Context, *GetClaudeLogsRequest) (*GetClaudeLogsResponse, error)
	// Configuration management
	GetAPIKey(context.Context, *GetAPIKeyRequest) (*GetAPIKeyResponse, error)
	SetAPIKey(context.Context, *SetAPIKeyRequest) (*SetAPIKeyResponse, error)
	ValidateAPIKey(context.Context, *ValidateAPIKeyRequest) (*ValidateAPIKeyResponse, error)
	mustEmbedUnimplementedDispenseServiceServer()
}

// UnimplementedDispenseServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDispenseServiceServer struct{}

func (UnimplementedDispenseServiceServer) CreateSandbox(context.Context, *CreateSandboxRequest) (*CreateSandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSandbox not implemented")
}
func (UnimplementedDispenseServiceServer) ListSandboxes(context.Context, *ListSandboxesRequest) (*ListSandboxesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSandboxes not implemented")
}
func (UnimplementedDispenseServiceServer) DeleteSandbox(context.Context, *DeleteSandboxRequest) (*DeleteSandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSandbox not implemented")
}
func (UnimplementedDispenseServiceServer) GetSandbox(context.Context, *GetSandboxRequest) (*GetSandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSandbox not implemented")
}
func (UnimplementedDispenseServiceServer) WaitForSandbox(context.Context, *WaitForSandboxRequest) (*WaitForSandboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForSandbox not implemented")
}
func (UnimplementedDispenseServiceServer) RunClaudeTask(*RunClaudeTaskRequest, grpc.ServerStreamingServer[RunClaudeTaskResponse]) error {
	return status.Errorf(codes.Unimplemented, "method RunClaudeTask not implemented")
}
func (UnimplementedDispenseServiceServer) GetClaudeStatus(context.Context, *GetClaudeStatusRequest) (*GetClaudeStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClaudeStatus not implemented")
}
func (UnimplementedDispenseServiceServer) GetClaudeLogs(context.Context, *GetClaudeLogsRequest) (*GetClaudeLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClaudeLogs not implemented")
}
func (UnimplementedDispenseServiceServer) GetAPIKey(context.Context, *GetAPIKeyRequest) (*GetAPIKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIKey not implemented")
}
func (UnimplementedDispenseServiceServer) SetAPIKey(context.Context, *SetAPIKeyRequest) (*SetAPIKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAPIKey not implemented")
}
func (UnimplementedDispenseServiceServer) ValidateAPIKey(context.Context, *ValidateAPIKeyRequest) (*ValidateAPIKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAPIKey not implemented")
}
func (UnimplementedDispenseServiceServer) mustEmbedUnimplementedDispenseServiceServer() {}
func (UnimplementedDispenseServiceServer) testEmbeddedByValue()                         {}

// UnsafeDispenseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DispenseServiceServer will
// result in compilation errors.
type UnsafeDispenseServiceServer interface {
	mustEmbedUnimplementedDispenseServiceServer()
}

func RegisterDispenseServiceServer(s grpc.ServiceRegistrar, srv DispenseServiceServer) {
	// If the following call pancis, it indicates UnimplementedDispenseServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DispenseService_ServiceDesc, srv)
}

func _DispenseService_CreateSandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).CreateSandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_CreateSandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).CreateSandbox(ctx, req.(*CreateSandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_ListSandboxes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSandboxesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).ListSandboxes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_ListSandboxes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).ListSandboxes(ctx, req.(*ListSandboxesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_DeleteSandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).DeleteSandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_DeleteSandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).DeleteSandbox(ctx, req.(*DeleteSandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_GetSandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).GetSandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_GetSandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).GetSandbox(ctx, req.(*GetSandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_WaitForSandbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForSandboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).WaitForSandbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_WaitForSandbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).WaitForSandbox(ctx, req.(*WaitForSandboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_RunClaudeTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunClaudeTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DispenseServiceServer).RunClaudeTask(m, &grpc.GenericServerStream[RunClaudeTaskRequest, RunClaudeTaskResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DispenseService_RunClaudeTaskServer = grpc.ServerStreamingServer[RunClaudeTaskResponse]

func _DispenseService_GetClaudeStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClaudeStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).GetClaudeStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_GetClaudeStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).GetClaudeStatus(ctx, req.(*GetClaudeStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_GetClaudeLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClaudeLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).GetClaudeLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_GetClaudeLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).GetClaudeLogs(ctx, req.(*GetClaudeLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_GetAPIKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAPIKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).GetAPIKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_GetAPIKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).GetAPIKey(ctx, req.(*GetAPIKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_SetAPIKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAPIKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).SetAPIKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_SetAPIKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).SetAPIKey(ctx, req.(*SetAPIKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DispenseService_ValidateAPIKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAPIKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DispenseServiceServer).ValidateAPIKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DispenseService_ValidateAPIKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DispenseServiceServer).ValidateAPIKey(ctx, req.(*ValidateAPIKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DispenseService_ServiceDesc is the grpc.ServiceDesc for DispenseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DispenseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dispense.DispenseService",
	HandlerType: (*DispenseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSandbox",
			Handler:    _DispenseService_CreateSandbox_Handler,
		},
		{
			MethodName: "ListSandboxes",
			Handler:    _DispenseService_ListSandboxes_Handler,
		},
		{
			MethodName: "DeleteSandbox",
			Handler:    _DispenseService_DeleteSandbox_Handler,
		},
		{
			MethodName: "GetSandbox",
			Handler:    _DispenseService_GetSandbox_Handler,
		},
		{
			MethodName: "WaitForSandbox",
			Handler:    _DispenseService_WaitForSandbox_Handler,
		},
		{
			MethodName: "GetClaudeStatus",
			Handler:    _DispenseService_GetClaudeStatus_Handler,
		},
		{
			MethodName: "GetClaudeLogs",
			Handler:    _DispenseService_GetClaudeLogs_Handler,
		},
		{
			MethodName: "GetAPIKey",
			Handler:    _DispenseService_GetAPIKey_Handler,
		},
		{
			MethodName: "SetAPIKey",
			Handler:    _DispenseService_SetAPIKey_Handler,
		},
		{
			MethodName: "ValidateAPIKey",
			Handler:    _DispenseService_ValidateAPIKey_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunClaudeTask",
			Handler:       _DispenseService_RunClaudeTask_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/dispense.proto",
}
